#Базовый синтаксис

В сегодняшнем занятии мы с вами разобрали основные понятия в SQL и базовый синтаксис формирования запроса. Помимо этого мы изучили понятия DDL и DML и основные команды создания таблиц и представлений.

## Различие между SQL и MySQL

Существует два различных понятия, SQL и СУБД.

SQL является языком программирования, который используется во множестве СУБД. SQL описывает концепции и синтаксис основных операций. Почти каждая СУБД включает в себя дополнительный функционал, специфичные для себя особенности и расширения.

Резюмируя, можно сказать, что SQL это набор правил для языка, а СУБД (Mysql, oracle, MS SQL) это реализация со своими специфичными особенностями. 

## SQL vs NoSQL

Все большую популярность набирает такое понятие, как NoSQL и возникают два вопроса:

- В чем отличие SQL от NoSQL
- Что лучше и перспективнее

Давайте разберемся по порядку на примере базы данных, которая описывает взаимодействие сущностей **Customer** (покупатель) и **Order** (заказ)

**В чем отличие SQL от NoSQL**

SQL позволяет нам работать с привычной для нас таблицей, у которой есть столбцы и строки. Если рассматривать наш пример, мы создадим две отдельные таблицы **Customer** и  **Order** и при необходимости объединим данные из этих таблиц

В NoSql ситуация совершенно иная, данные представляются в виде графа и имеют каскадную структуру, скажем в наборе данных о **Customer**  у нас будет свойство **Order,** которое содержит в себе все заказы покупателя.

**Что лучше и перспективнее**

На данный момент NoSQL приобретает популярность и является "модным" направлением, он действительно хорош для решения узко профилированных задач, однако SQL существует значительно дольше и накопленный опыт и экспертизы позволяют нам реализовывать достаточно сложную архитектуру, делая ее масштабируемой и удобной в использовании. 

Резюмируя можно сказать, что SQL еще множество лет будет впереди и в любом случае, даже при желании использовать NoSQL необходимо знать SQL на достаточно хорошем уровне. 

## Основные понятия у таблицы

Для более удобной работы нам необходимо ввести ряд понятий:

1) Поле, атрибут, столбец. Часть таблицы, определяющая одно из свойств. (располагается вертикально)

2) Запись, строка. Часть таблицы, которая хранит информацию об одной описанной единице. (располагается горизонтально)

3) Поле. Ячейка в таблице, которую можно однозначно определить по строке и столбцу.

3) Таблица. Сущность в базе данных, которая хранит в себе данные. Имеет строгую структуру и типизированные поля. Хранится на жестком диске.

4) Выборка. Набор данных, полученных в результате запроса SELECT. Хранится в оперативной памяти.

5) Запрос. Команда на SQL, предназначенная для получения или изменение данных, или структуры сущностей в базе данных.

В результате запроса из таблицы можно получить выборку с определенными записями и полями.

## Формирование выборки

Для формирования выборки необходимо использовать специальный запрос SELECT имеющий следующую структуру:

```sql
SELECT
	*
FROM users
WHERE name = 'Анатолий' 
  and lastname = 'Ушанов'
```

В разделе SELECT можно указать множество полей через запятую или * (все поля)

В разделе FROM указывается таблицы источник. 

В разделе WHERE указываются условия.

[Для формирования условий используются следующие операторы.](https://www.notion.so/06bb8a5111e1448fb6a36003ca5a1d6a)

```sql
-- запрос будет работать при условии существования таблицы
-- users с используемыми полями

SELECT
	name,
	lastname
FROM users
WHERE (name = 'Анатолий' 
  and lastname = 'Ушанов'
	and age between 12 and 34
	and city not in ('Moscow', 'Erevan')
	and email like '%@gamil.com'
	) or gender = 'M'
```

## Разбор задания из класса

Задание:

Из таблицы **HR.EMPLOYEES**

```sql
-- 1 задание (найти всех сотрудников, c job_id = IT_PROG)
SELECT 
	*
from HR.EMPLOYEES
where job_id = 'IT_PROG'

-- 2 задание (найти сотрудников, с зп больше 10 000)
SELECT 
	*
from HR.EMPLOYEES
where salary > 10000

-- 3 задание (найти сотрудников, с зп от 10 000 до 20 000 (включая концы))
SELECT 
	*
from HR.EMPLOYEES
where salary between 10000 and 20000

-- 4 задание (найти сотрудников не из 60, 30 и 100 департамента)
SELECT 
	*
from HR.EMPLOYEES
where department_id in (60, 30, 100)

-- 5 задание (найти сотрудников у которых есть две буквы ll подряд в середине имени)
SELECT 
	*
from HR.EMPLOYEES
where FIRST_NAME like '%_ll_%'
 
-- 6 задание (найти сотрудников, у которых фамилия кончается на a)
SELECT 
	*
from HR.EMPLOYEES
where FIRST_NAME like '%a'
```

## Особенности значения Null

В SQL существует значение Null, которое обозначает отсутствие значения в поле. Не стоит путать значение Null со значением 0 и пустой строкой (""). И их нельзя сравнивать ранее изученными операторами.

Для лучшего представления смысла значения Null я хочу вас познакомить с Петей и Колей. 

П:  "Коля, какая завтра погода?"

К:  "Не знаю, я не планировал завтра никуда выходить."

П: "Хорошо, может ты знаешь, какая после завтра погода?"

К: "Нет, вышел новый сезон Рика и Морти и я планирую всю неделю засматривать его до дыр"

Из этого диалога мы можем сделать вывод, что у Коли отличный вкус на сериалы и что он не знает, какая будет погода завтра или послезавтра. 

- Можем ли мы сказать, что погода будет 0 градусов? **Нет**
- Можем ли мы сказать, что завтра и после завтра будет одинаковая погода? **Нет.** Может в итоге и окажется, что она и будет одинаковой, однако сейчас это утверждение ложно.
- Можем ли мы сказать, что завтра и после завтра будет разная погода? **Нет.** Все по той же причине.

Мы можем лишь определить, является данное значение Null или нет, для этого существуют специальные операторы 

(https://www.notion.so/fe1d1725500b4ca29f05f8e4021c45b5)

## Оператор **distinct**

Оператор distinct позволяет убрать дубли у запроса, это достаточно мощный инструмент, однако использовать его нужно только в уместных случаях. 

Зачастую возникновение дублей сигнализирует нам о том, что мы сделали в запросе что-то неверно. Использование distinct в таком случае не только неправильно с архитектурной точки зрения (в простонародий костыль), но и сильно негативно влияет на время выполнения запроса.

Все дело в том, что для нахождения дублей distinct прежде сортирует записи, а сортировка очень ресурса затратный процесс.

Используйте distinct только в тех случаях, где вы понимаете причину возникновения дублей, и что она заключается не в неправильном запросе.

```sql
-- запрос вернет уникальные пары имени и фамилии

SELECT distinct
	name,
	lastname
FROM users
```

## Разбор задания из класса

Задание:

Из таблицы **HR.EMPLOYEES**

```sql
-- 1 задание (найти все имеющиеся job_id)
SELECT distinct
	job_id
from HR.EMPLOYEES

-- 2 задание (найти job_id у которых нет COMMISSION_PCT или зп меньше 3000)
SELECT distinct
	*
from HR.EMPLOYEES
where COMMISSION_PCT is null 
or salary < 3000
```